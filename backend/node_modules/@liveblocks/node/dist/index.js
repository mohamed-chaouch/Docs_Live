"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _nullishCoalesce(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } } function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }// src/index.ts
var _core = require('@liveblocks/core');

// src/version.ts
var PKG_NAME = "@liveblocks/node";
var PKG_VERSION = "2.13.0";
var PKG_FORMAT = "cjs";

// src/client.ts










// src/Session.ts


// src/utils.ts
var DEFAULT_BASE_URL = "https://api.liveblocks.io";
var VALID_KEY_CHARS_REGEX = /^[\w-]+$/;
function getBaseUrl(baseUrl) {
  if (typeof baseUrl === "string" && baseUrl.startsWith("http")) {
    return baseUrl;
  } else {
    return DEFAULT_BASE_URL;
  }
}
async function fetchPolyfill() {
  return typeof globalThis.fetch !== "undefined" ? globalThis.fetch : (await Promise.resolve().then(() => _interopRequireWildcard(require("node-fetch")))).default;
}
function isString(value) {
  return typeof value === "string";
}
function startsWith(value, prefix) {
  return isString(value) && value.startsWith(prefix);
}
function isNonEmpty(value) {
  return isString(value) && value.length > 0;
}
function assertNonEmpty(value, field) {
  if (!isNonEmpty(value)) {
    throw new Error(
      `Invalid value for field '${field}'. Please provide a non-empty string. For more information: https://liveblocks.io/docs/api-reference/liveblocks-node#authorize`
    );
  }
}
function assertSecretKey(value, field) {
  if (!startsWith(value, "sk_")) {
    throw new Error(
      `Invalid value for field '${field}'. Secret keys must start with 'sk_'. Please provide the secret key from your Liveblocks dashboard at https://liveblocks.io/dashboard/apikeys.`
    );
  }
  if (!VALID_KEY_CHARS_REGEX.test(value)) {
    throw new Error(
      `Invalid chars found in field '${field}'. Please check that you correctly copied the secret key from your Liveblocks dashboard at https://liveblocks.io/dashboard/apikeys.`
    );
  }
}
function normalizeStatusCode(statusCode) {
  if (statusCode >= 200 && statusCode < 300) {
    return 200;
  } else if (statusCode >= 500) {
    return 503;
  } else {
    return 403;
  }
}

// src/Session.ts
var ALL_PERMISSIONS = Object.freeze([
  "room:write",
  "room:read",
  "room:presence:write",
  "comments:write",
  "comments:read"
]);
function isPermission(value) {
  return ALL_PERMISSIONS.includes(value);
}
var MAX_PERMS_PER_SET = 10;
var READ_ACCESS = Object.freeze([
  "room:read",
  "room:presence:write",
  "comments:read"
]);
var FULL_ACCESS = Object.freeze(["room:write", "comments:write"]);
var roomPatternRegex = /^([*]|[^*]{1,128}[*]?)$/;
var Session = class {
  /** @internal */
  constructor(postFn, userId, userInfo) {
    this.FULL_ACCESS = FULL_ACCESS;
    this.READ_ACCESS = READ_ACCESS;
    /** @internal */
    this._sealed = false;
    /** @internal */
    this._permissions = /* @__PURE__ */ new Map();
    assertNonEmpty(userId, "userId");
    this._postFn = postFn;
    this._userId = userId;
    this._userInfo = userInfo;
  }
  /** @internal */
  getOrCreate(roomId) {
    if (this._sealed) {
      throw new Error("You can no longer change these permissions.");
    }
    let perms = this._permissions.get(roomId);
    if (perms) {
      return perms;
    } else {
      if (this._permissions.size >= MAX_PERMS_PER_SET) {
        throw new Error(
          "You cannot add permissions for more than 10 rooms in a single token"
        );
      }
      perms = /* @__PURE__ */ new Set();
      this._permissions.set(roomId, perms);
      return perms;
    }
  }
  allow(roomIdOrPattern, newPerms) {
    if (typeof roomIdOrPattern !== "string") {
      throw new Error("Room name or pattern must be a string");
    }
    if (!roomPatternRegex.test(roomIdOrPattern)) {
      throw new Error("Invalid room name or pattern");
    }
    if (newPerms.length === 0) {
      throw new Error("Permission list cannot be empty");
    }
    const existingPerms = this.getOrCreate(roomIdOrPattern);
    for (const perm of newPerms) {
      if (!isPermission(perm)) {
        throw new Error(`Not a valid permission: ${perm}`);
      }
      existingPerms.add(perm);
    }
    return this;
  }
  /** @internal - For unit tests only */
  hasPermissions() {
    return this._permissions.size > 0;
  }
  /** @internal - For unit tests only */
  seal() {
    if (this._sealed) {
      throw new Error(
        "You cannot reuse Session instances. Please create a new session every time."
      );
    }
    this._sealed = true;
  }
  /** @internal - For unit tests only */
  serializePermissions() {
    return Object.fromEntries(
      Array.from(this._permissions.entries()).map(([pat, perms]) => [
        pat,
        Array.from(perms)
      ])
    );
  }
  /**
   * Call this to authorize the session to access Liveblocks. Note that this
   * will return a Liveblocks "access token". Anyone that obtains such access
   * token will have access to the allowed resources.
   */
  async authorize() {
    this.seal();
    if (!this.hasPermissions()) {
      console.warn(
        "Access tokens without any permission will not be supported soon, you should use wildcards when the client requests a token for resources outside a room. See https://liveblocks.io/docs/errors/liveblocks-client/access-tokens-not-enough-permissions"
      );
    }
    try {
      const resp = await this._postFn(_core.url`/v2/authorize-user`, {
        // Required
        userId: this._userId,
        permissions: this.serializePermissions(),
        // Optional metadata
        userInfo: this._userInfo
      });
      return {
        status: normalizeStatusCode(resp.status),
        body: await resp.text()
      };
    } catch (er) {
      return {
        status: 503,
        body: 'Call to /v2/authorize-user failed. See "error" for more information.',
        error: er
      };
    }
  }
};

// src/client.ts
var Liveblocks = class {
  /**
   * Interact with the Liveblocks API from your Node.js backend.
   */
  constructor(options) {
    const options_ = options;
    const secret = options_.secret;
    assertSecretKey(secret, "secret");
    this._secret = secret;
    this._baseUrl = new URL(getBaseUrl(options.baseUrl));
  }
  /** @internal */
  async post(path, json) {
    const url3 = _core.urljoin.call(void 0, this._baseUrl, path);
    const headers = {
      Authorization: `Bearer ${this._secret}`,
      "Content-Type": "application/json"
    };
    const fetch = await fetchPolyfill();
    const res = await fetch(url3, {
      method: "POST",
      headers,
      body: JSON.stringify(json)
    });
    return res;
  }
  /** @internal */
  async put(path, json) {
    const url3 = _core.urljoin.call(void 0, this._baseUrl, path);
    const headers = {
      Authorization: `Bearer ${this._secret}`,
      "Content-Type": "application/json"
    };
    const fetch = await fetchPolyfill();
    return await fetch(url3, {
      method: "PUT",
      headers,
      body: JSON.stringify(json)
    });
  }
  /** @internal */
  async putBinary(path, body, params) {
    const url3 = _core.urljoin.call(void 0, this._baseUrl, path, params);
    const headers = {
      Authorization: `Bearer ${this._secret}`,
      "Content-Type": "application/octet-stream"
    };
    const fetch = await fetchPolyfill();
    return await fetch(url3, { method: "PUT", headers, body });
  }
  /** @internal */
  async delete(path) {
    const url3 = _core.urljoin.call(void 0, this._baseUrl, path);
    const headers = {
      Authorization: `Bearer ${this._secret}`
    };
    const fetch = await fetchPolyfill();
    const res = await fetch(url3, { method: "DELETE", headers });
    return res;
  }
  /** @internal */
  async get(path, params) {
    const url3 = _core.urljoin.call(void 0, this._baseUrl, path, params);
    const headers = {
      Authorization: `Bearer ${this._secret}`
    };
    const fetch = await fetchPolyfill();
    const res = await fetch(url3, { method: "GET", headers });
    return res;
  }
  /* -------------------------------------------------------------------------------------------------
   * Authentication
   * -----------------------------------------------------------------------------------------------*/
  /**
   * Prepares a new session to authorize a user to access Liveblocks.
   *
   * IMPORTANT:
   * Always make sure that you trust the user making the request to your
   * backend before calling .prepareSession()!
   *
   * @param userId Tell Liveblocks the user ID of the user to authorize. Must
   * uniquely identify the user account in your system. The uniqueness of this
   * value will determine how many MAUs will be counted/billed.
   *
   * @param options.userInfo Custom metadata to attach to this user. Data you
   * add here will be visible to all other clients in the room, through the
   * `other.info` property.
   *
   */
  prepareSession(userId, ...rest) {
    const options = rest[0];
    return new Session(this.post.bind(this), userId, _optionalChain([options, 'optionalAccess', _ => _.userInfo]));
  }
  /**
   * Call this to authenticate the user as an actor you want to allow to use
   * Liveblocks.
   *
   * You should use this method only if you want to manage your permissions
   * through the Liveblocks Permissions API. This method is more complicated to
   * set up, but allows for finer-grained specification of permissions.
   *
   * Calling `.identifyUser()` only lets you securely identify a user (and what
   * groups they belong to). What permissions this user will end up having is
   * determined by whatever permissions you assign the user/group in your
   * Liveblocks account, through the Permissions API:
   * https://liveblocks.io/docs/rooms/permissions
   *
   * IMPORTANT:
   * Always verify that you trust the user making the request before calling
   * .identifyUser()!
   *
   * @param identity Tell Liveblocks the user ID of the user to authenticate.
   * Must uniquely identify the user account in your system. The uniqueness of
   * this value will determine how many MAUs will be counted/billed.
   *
   * If you also want to assign which groups this user belongs to, use the
   * object form and specify the `groupIds` property. Those `groupIds` should
   * match the groupIds you assigned permissions to via the Liveblocks
   * Permissions API, see
   * https://liveblocks.io/docs/rooms/permissions#permissions-levels-groups-accesses-example
   *
   * @param options.userInfo Custom metadata to attach to this user. Data you
   * add here will be visible to all other clients in the room, through the
   * `other.info` property.
   */
  // These fields define the security identity of the user. Whatever you pass in here will define which
  async identifyUser(identity, ...rest) {
    const options = rest[0];
    const path = _core.url`/v2/identify-user`;
    const userId = typeof identity === "string" ? identity : identity.userId;
    const groupIds = typeof identity === "string" ? void 0 : identity.groupIds;
    assertNonEmpty(userId, "userId");
    try {
      const resp = await this.post(path, {
        userId,
        groupIds,
        // Optional metadata
        userInfo: _optionalChain([options, 'optionalAccess', _2 => _2.userInfo])
      });
      return {
        status: normalizeStatusCode(resp.status),
        body: await resp.text()
      };
    } catch (er) {
      return {
        status: 503,
        body: `Call to ${_core.urljoin.call(void 0, 
          this._baseUrl,
          path
        )} failed. See "error" for more information.`,
        error: er
      };
    }
  }
  /* -------------------------------------------------------------------------------------------------
   * Room
   * -----------------------------------------------------------------------------------------------*/
  /**
   * Returns a list of your rooms. The rooms are returned sorted by creation date, from newest to oldest. You can filter rooms by metadata, users accesses and groups accesses.
   * @param params.limit (optional) A limit on the number of rooms to be returned. The limit can range between 1 and 100, and defaults to 20.
   * @param params.startingAfter (optional) A cursor used for pagination. You get the value from the response of the previous page.
   * @param params.userId (optional) A filter on users accesses.
   * @param params.metadata (optional) A filter on metadata. Multiple metadata keys can be used to filter rooms.
   * @param params.groupIds (optional) A filter on groups accesses. Multiple groups can be used.
   * @param params.query (optional) A query to filter rooms by. It is based on our query language. You can filter by metadata and room ID.
   * @returns A list of rooms.
   */
  async getRooms(params = {}) {
    const path = _core.url`/v2/rooms`;
    let query;
    if (typeof params.query === "string") {
      query = params.query;
    } else if (typeof params.query === "object") {
      query = _core.objectToQuery.call(void 0, params.query);
    }
    const queryParams = {
      limit: params.limit,
      startingAfter: params.startingAfter,
      userId: params.userId,
      groupIds: params.groupIds ? params.groupIds.join(",") : void 0,
      // "Flatten" {metadata: {foo: "bar"}} to {"metadata.foo": "bar"}
      ...Object.fromEntries(
        Object.entries(_nullishCoalesce(params.metadata, () => ( {}))).map(([key, val]) => [
          `metadata.${key}`,
          val
        ])
      ),
      query
    };
    const res = await this.get(path, queryParams);
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
    const data = await res.json();
    const rooms = data.data.map((room) => {
      const lastConnectionAt = room.lastConnectionAt ? new Date(room.lastConnectionAt) : void 0;
      const createdAt = new Date(room.createdAt);
      return {
        ...room,
        createdAt,
        lastConnectionAt
      };
    });
    return {
      ...data,
      data: rooms
    };
  }
  /**
   * Creates a new room with the given id.
   * @param roomId The id of the room to create.
   * @param params.defaultAccesses The default accesses for the room.
   * @param params.groupsAccesses (optional) The group accesses for the room. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.
   * @param params.usersAccesses (optional) The user accesses for the room. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.
   * @param params.metadata (optional) The metadata for the room. Supports upto a maximum of 50 entries. Key length has a limit of 40 characters. Value length has a limit of 256 characters.
   * @returns The created room.
   */
  async createRoom(roomId, params) {
    const { defaultAccesses, groupsAccesses, usersAccesses, metadata } = params;
    const res = await this.post(_core.url`/v2/rooms`, {
      id: roomId,
      defaultAccesses,
      groupsAccesses,
      usersAccesses,
      metadata
    });
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
    const data = await res.json();
    const lastConnectionAt = data.lastConnectionAt ? new Date(data.lastConnectionAt) : void 0;
    const createdAt = new Date(data.createdAt);
    return {
      ...data,
      lastConnectionAt,
      createdAt
    };
  }
  /**
   * Returns a room with the given id.
   * @param roomId The id of the room to return.
   * @returns The room with the given id.
   */
  async getRoom(roomId) {
    const res = await this.get(_core.url`/v2/rooms/${roomId}`);
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
    const data = await res.json();
    const lastConnectionAt = data.lastConnectionAt ? new Date(data.lastConnectionAt) : void 0;
    const createdAt = new Date(data.createdAt);
    return {
      ...data,
      createdAt,
      lastConnectionAt
    };
  }
  /**
   * Updates specific properties of a room. It’s not necessary to provide the entire room’s information.
   * Setting a property to `null` means to delete this property.
   * @param roomId The id of the room to update.
   * @param params.defaultAccesses (optional) The default accesses for the room.
   * @param params.groupsAccesses (optional) The group accesses for the room. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.
   * @param params.usersAccesses (optional) The user accesses for the room. Can contain a maximum of 100 entries. Key length has a limit of 40 characters.
   * @param params.metadata (optional) The metadata for the room. Supports upto a maximum of 50 entries. Key length has a limit of 40 characters. Value length has a limit of 256 characters.
   * @returns The updated room.
   */
  async updateRoom(roomId, params) {
    const { defaultAccesses, groupsAccesses, usersAccesses, metadata } = params;
    const res = await this.post(_core.url`/v2/rooms/${roomId}`, {
      defaultAccesses,
      groupsAccesses,
      usersAccesses,
      metadata
    });
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
    const data = await res.json();
    const lastConnectionAt = data.lastConnectionAt ? new Date(data.lastConnectionAt) : void 0;
    const createdAt = new Date(data.createdAt);
    return {
      ...data,
      lastConnectionAt,
      createdAt
    };
  }
  /**
   * Deletes a room with the given id. A deleted room is no longer accessible from the API or the dashboard and it cannot be restored.
   * @param roomId The id of the room to delete.
   */
  async deleteRoom(roomId) {
    const res = await this.delete(_core.url`/v2/rooms/${roomId}`);
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
  }
  /**
   * Returns a list of users currently present in the requested room. For better performance, we recommand to call this endpoint every 10 seconds maximum. Duplicates can happen if a user is in the requested room with multiple browser tabs opened.
   * @param roomId The id of the room to get the users from.
   * @returns A list of users currently present in the requested room.
   */
  async getActiveUsers(roomId) {
    const res = await this.get(_core.url`/v2/rooms/${roomId}/active_users`);
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
    return await res.json();
  }
  /**
   * Boadcasts an event to a room without having to connect to it via the client from @liveblocks/client. The connectionId passed to event listeners is -1 when using this API.
   * @param roomId The id of the room to broadcast the event to.
   * @param message The message to broadcast. It can be any JSON serializable value.
   */
  async broadcastEvent(roomId, message) {
    const res = await this.post(
      _core.url`/v2/rooms/${roomId}/broadcast_event`,
      message
    );
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
  }
  async getStorageDocument(roomId, format = "plain-lson") {
    const res = await this.get(_core.url`/v2/rooms/${roomId}/storage`, { format });
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
    return await res.json();
  }
  /**
   * Initializes a room’s Storage. The room must already exist and have an empty Storage.
   * Calling this endpoint will disconnect all users from the room if there are any.
   *
   * @param roomId The id of the room to initialize the storage from.
   * @param document The document to initialize the storage with.
   * @returns The initialized storage document. It is of the same format as the one passed in.
   */
  async initializeStorageDocument(roomId, document) {
    const res = await this.post(_core.url`/v2/rooms/${roomId}/storage`, document);
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
    return await res.json();
  }
  /**
   * Deletes all of the room’s Storage data and disconnect all users from the room if there are any. Note that this does not delete the Yjs document in the room if one exists.
   * @param roomId The id of the room to delete the storage from.
   */
  async deleteStorageDocument(roomId) {
    const res = await this.delete(_core.url`/v2/rooms/${roomId}/storage`);
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
  }
  /* -------------------------------------------------------------------------------------------------
   * Yjs
   * -----------------------------------------------------------------------------------------------*/
  /**
   * Returns a JSON representation of the room’s Yjs document.
   * @param roomId The id of the room to get the Yjs document from.
   * @param params.format (optional) If true, YText will return formatting.
   * @param params.key (optional) If provided, returns only a single key’s value, e.g. doc.get(key).toJSON().
   * @param params.type (optional) Used with key to override the inferred type, i.e. "ymap" will return doc.get(key, Y.Map).
   * @returns A JSON representation of the room’s Yjs document.
   */
  async getYjsDocument(roomId, params = {}) {
    const { format, key, type } = params;
    const path = _core.url`v2/rooms/${roomId}/ydoc`;
    const res = await this.get(path, {
      formatting: format ? "true" : void 0,
      key,
      type
    });
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
    return await res.json();
  }
  /**
   * Send a Yjs binary update to the room’s Yjs document. You can use this endpoint to initialize Yjs data for the room or to update the room’s Yjs document.
   * @param roomId The id of the room to send the Yjs binary update to.
   * @param update The Yjs update to send. Typically the result of calling `Yjs.encodeStateAsUpdate(doc)`. Read the [Yjs documentation](https://docs.yjs.dev/api/document-updates) to learn how to create a binary update.
   * @param params.guid (optional) If provided, the binary update will be applied to the Yjs subdocument with the given guid. If not provided, the binary update will be applied to the root Yjs document.
   */
  async sendYjsBinaryUpdate(roomId, update, params = {}) {
    const res = await this.putBinary(_core.url`/v2/rooms/${roomId}/ydoc`, update, {
      guid: params.guid
    });
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
  }
  /**
   * Returns the room’s Yjs document encoded as a single binary update. This can be used by Y.applyUpdate(responseBody) to get a copy of the document in your backend.
   * See [Yjs documentation](https://docs.yjs.dev/api/document-updates) for more information on working with updates.
   * @param roomId The id of the room to get the Yjs document from.
   * @param params.guid (optional) If provided, returns the binary update of the Yjs subdocument with the given guid. If not provided, returns the binary update of the root Yjs document.
   * @returns The room’s Yjs document encoded as a single binary update.
   */
  async getYjsDocumentAsBinaryUpdate(roomId, params = {}) {
    const res = await this.get(_core.url`/v2/rooms/${roomId}/ydoc-binary`, {
      guid: params.guid
    });
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
    return res.arrayBuffer();
  }
  /* -------------------------------------------------------------------------------------------------
   * Schema Validation
   * -----------------------------------------------------------------------------------------------*/
  /**
   * Creates a new schema which can be referenced later to enforce a room’s Storage data structure.
   * @param name The name used to reference the schema. Must be a non-empty string with less than 65 characters and only contain lowercase letters, numbers and dashes
   * @param body The exact allowed shape of data in the room. It is a multi-line string written in the [Liveblocks schema syntax](https://liveblocks.io/docs/platform/schema-validation/syntax).
   * @returns The created schema.
   */
  async createSchema(name, body) {
    const res = await this.post(_core.url`/v2/schemas`, {
      name,
      body
    });
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
    const data = await res.json();
    const createdAt = new Date(data.createdAt);
    const updatedAt = new Date(data.updatedAt);
    return {
      ...data,
      createdAt,
      updatedAt
    };
  }
  /**
   * Returns a schema by its id.
   * @param schemaId Id of the schema - this is the combination of the schema name and version of the schema to update. For example, `my-schema@1`.
   * @returns The schema with the given id.
   */
  async getSchema(schemaId) {
    const res = await this.get(_core.url`/v2/schemas/${schemaId}`);
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
    const data = await res.json();
    const createdAt = new Date(data.createdAt);
    const updatedAt = new Date(data.updatedAt);
    return {
      ...data,
      createdAt,
      updatedAt
    };
  }
  /**
   * Updates the body for the schema. A schema can only be updated if it is not used by any room.
   * @param schemaId Id of the schema - this is the combination of the schema name and version of the schema to update. For example, `my-schema@1`.
   * @param body The exact allowed shape of data in the room. It is a multi-line string written in the [Liveblocks schema syntax](https://liveblocks.io/docs/platform/schema-validation/syntax).
   * @returns The updated schema. The version of the schema will be incremented.
   */
  async updateSchema(schemaId, body) {
    const res = await this.put(_core.url`/v2/schemas/${schemaId}`, {
      body
    });
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
    const data = await res.json();
    const createdAt = new Date(data.createdAt);
    const updatedAt = new Date(data.updatedAt);
    return {
      ...data,
      createdAt,
      updatedAt
    };
  }
  /**
   * Deletes a schema by its id. A schema can only be deleted if it is not used by any room.
   * @param schemaId Id of the schema - this is the combination of the schema name and version of the schema to update. For example, `my-schema@1`.
   */
  async deleteSchema(schemaId) {
    const res = await this.delete(_core.url`/v2/schemas/${schemaId}`);
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
  }
  /**
   * Returns the schema attached to a room.
   * @param roomId The id of the room to get the schema from.
   * @returns
   */
  async getSchemaByRoomId(roomId) {
    const res = await this.get(_core.url`/v2/rooms/${roomId}/schema`);
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
    const data = await res.json();
    const createdAt = new Date(data.createdAt);
    const updatedAt = new Date(data.updatedAt);
    return {
      ...data,
      createdAt,
      updatedAt
    };
  }
  /**
   * Attaches a schema to a room, and instantly enables runtime schema validation for the room.
   * If the current contents of the room’s Storage do not match the schema, attaching will fail and the error message will give details on why the schema failed to attach.
   * @param roomId The id of the room to attach the schema to.
   * @param schemaId Id of the schema - this is the combination of the schema name and version of the schema to update. For example, `my-schema@1`.
   * @returns The schema id as JSON.
   */
  async attachSchemaToRoom(roomId, schemaId) {
    const res = await this.post(_core.url`/v2/rooms/${roomId}/schema`, {
      schema: schemaId
    });
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
    return await res.json();
  }
  /**
   * Detaches a schema from a room, and disables runtime schema validation for the room.
   * @param roomId The id of the room to detach the schema from.
   */
  async detachSchemaFromRoom(roomId) {
    const res = await this.delete(_core.url`/v2/rooms/${roomId}/schema`);
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
  }
  /* -------------------------------------------------------------------------------------------------
   * Comments
   * -----------------------------------------------------------------------------------------------*/
  /**
   * Gets all the threads in a room.
   *
   * @param params.roomId The room ID to get the threads from.
   * @param params.query The query to filter threads by. It is based on our query language and can filter by metadata.
   * @returns A list of threads.
   */
  async getThreads(params) {
    const { roomId } = params;
    let query;
    if (typeof params.query === "string") {
      query = params.query;
    } else if (typeof params.query === "object") {
      query = _core.objectToQuery.call(void 0, params.query);
    }
    const res = await this.get(_core.url`/v2/rooms/${roomId}/threads`, {
      query
    });
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
    const { data } = await res.json();
    return {
      data: data.map((thread) => _core.convertToThreadData.call(void 0, thread))
    };
  }
  /**
   * Gets a thread.
   *
   * @param params.roomId The room ID to get the thread from.
   * @param params.threadId The thread ID.
   * @returns A thread.
   */
  async getThread(params) {
    const { roomId, threadId } = params;
    const res = await this.get(_core.url`/v2/rooms/${roomId}/threads/${threadId}`);
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
    return _core.convertToThreadData.call(void 0, await res.json());
  }
  /**
   * Gets a thread's participants.
   *
   * Participants are users who have commented on the thread
   * or users and groups that have been mentioned in a comment.
   *
   * @param params.roomId The room ID to get the thread participants from.
   * @param params.threadId The thread ID to get the participants from.
   * @returns An object containing an array of participant IDs.
   */
  async getThreadParticipants(params) {
    const { roomId, threadId } = params;
    const res = await this.get(
      _core.url`/v2/rooms/${roomId}/threads/${threadId}/participants`
    );
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
    return await res.json();
  }
  /**
   * Gets a thread's comment.
   *
   * @param params.roomId The room ID to get the comment from.
   * @param params.threadId The thread ID to get the comment from.
   * @param params.commentId The comment ID.
   * @returns A comment.
   */
  async getComment(params) {
    const { roomId, threadId, commentId } = params;
    const res = await this.get(
      _core.url`/v2/rooms/${roomId}/threads/${threadId}/comments/${commentId}`
    );
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
    return _core.convertToCommentData.call(void 0, await res.json());
  }
  /**
   * Creates a comment.
   *
   * @param params.roomId The room ID to create the comment in.
   * @param params.threadId The thread ID to create the comment in.
   * @param params.data.userId The user ID of the user who is set to create the comment.
   * @param params.data.createdAt (optional) The date the comment is set to be created.
   * @param params.data.body The body of the comment.
   * @returns The created comment.
   */
  async createComment(params) {
    const { roomId, threadId, data } = params;
    const res = await this.post(
      _core.url`/v2/rooms/${roomId}/threads/${threadId}/comments`,
      {
        ...data,
        createdAt: _optionalChain([data, 'access', _3 => _3.createdAt, 'optionalAccess', _4 => _4.toISOString, 'call', _5 => _5()])
      }
    );
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
    return _core.convertToCommentData.call(void 0, await res.json());
  }
  /**
   * Edits a comment.
   * @param params.roomId The room ID to edit the comment in.
   * @param params.threadId The thread ID to edit the comment in.
   * @param params.commentId The comment ID to edit.
   * @param params.data.body The body of the comment.
   * @param params.data.editedAt (optional) The date the comment was edited.
   * @returns The edited comment.
   */
  async editComment(params) {
    const { roomId, threadId, commentId, data } = params;
    const res = await this.post(
      _core.url`/v2/rooms/${roomId}/threads/${threadId}/comments/${commentId}`,
      {
        ...data,
        editedAt: _optionalChain([data, 'access', _6 => _6.editedAt, 'optionalAccess', _7 => _7.toISOString, 'call', _8 => _8()])
      }
    );
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
    return _core.convertToCommentData.call(void 0, await res.json());
  }
  /**
   * Deletes a comment. Deletes a comment. If there are no remaining comments in the thread, the thread is also deleted.
   * @param params.roomId The room ID to delete the comment in.
   * @param params.threadId The thread ID to delete the comment in.
   * @param params.commentId The comment ID to delete.
   */
  async deleteComment(params) {
    const { roomId, threadId, commentId } = params;
    const res = await this.delete(
      _core.url`/v2/rooms/${roomId}/threads/${threadId}/comments/${commentId}`
    );
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
  }
  /**
   * Creates a new thread. The thread will be created with the specified comment as its first comment.
   * If the thread already exists, a `LiveblocksError` will be thrown with status code 409.
   * @param params.roomId The room ID to create the thread in.
   * @param params.thread.metadata (optional) The metadata for the thread. Supports upto a maximum of 10 entries. Value must be a string, boolean or number
   * @param params.thread.comment.userId The user ID of the user who created the comment.
   * @param params.thread.comment.createdAt (optional) The date the comment was created.
   * @param params.thread.comment.body The body of the comment.
   * @returns The created thread. The thread will be created with the specified comment as its first comment.
   */
  async createThread(params) {
    const { roomId, data } = params;
    const res = await this.post(_core.url`/v2/rooms/${roomId}/threads`, {
      ...data,
      comment: {
        ...data.comment,
        createdAt: _optionalChain([data, 'access', _9 => _9.comment, 'access', _10 => _10.createdAt, 'optionalAccess', _11 => _11.toISOString, 'call', _12 => _12()])
      }
    });
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
    return _core.convertToThreadData.call(void 0, await res.json());
  }
  /**
   * Deletes a thread and all of its comments.
   * @param params.roomId The room ID to delete the thread in.
   * @param params.threadId The thread ID to delete.
   */
  async deleteThread(params) {
    const { roomId, threadId } = params;
    const res = await this.delete(_core.url`/v2/rooms/${roomId}/threads/${threadId}`);
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
  }
  /**
   * Mark a thread as resolved.
   * @param params.roomId The room ID of the thread.
   * @param params.threadId The thread ID to mark as resolved.
   * @param params.data.userId The user ID of the user who marked the thread as resolved.
   * @returns The thread marked as resolved.
   */
  async markThreadAsResolved(params) {
    const { roomId, threadId } = params;
    const res = await this.post(
      _core.url`/v2/rooms/${roomId}/threads/${threadId}/mark-as-resolved`,
      {}
    );
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
    return _core.convertToThreadData.call(void 0, await res.json());
  }
  /**
   * Mark a thread as unresolved.
   * @param params.roomId The room ID of the thread.
   * @param params.threadId The thread ID to mark as unresolved.
   * @param params.data.userId The user ID of the user who marked the thread as unresolved.
   * @returns The thread marked as unresolved.
   */
  async markThreadAsUnresolved(params) {
    const { roomId, threadId } = params;
    const res = await this.post(
      _core.url`/v2/rooms/${roomId}/threads/${threadId}/mark-as-unresolved`,
      {}
    );
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
    return _core.convertToThreadData.call(void 0, await res.json());
  }
  /**
   * Updates the metadata of the specified thread in a room.
   * @param params.roomId The room ID to update the thread in.
   * @param params.threadId The thread ID to update.
   * @param params.data.metadata The metadata for the thread. Value must be a string, boolean or number
   * @param params.data.userId The user ID of the user who updated the thread.
   * @param params.data.updatedAt (optional) The date the thread is set to be updated.
   * @returns The updated thread metadata.
   */
  async editThreadMetadata(params) {
    const { roomId, threadId, data } = params;
    const res = await this.post(
      _core.url`/v2/rooms/${roomId}/threads/${threadId}/metadata`,
      {
        ...data,
        updatedAt: _optionalChain([data, 'access', _13 => _13.updatedAt, 'optionalAccess', _14 => _14.toISOString, 'call', _15 => _15()])
      }
    );
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
    return await res.json();
  }
  /**
   * Adds a new comment reaction to a comment.
   * @param params.roomId The room ID to add the comment reaction in.
   * @param params.threadId The thread ID to add the comment reaction in.
   * @param params.commentId The comment ID to add the reaction in.
   * @param params.data.emoji The (emoji) reaction to add.
   * @param params.data.userId The user ID of the user associated with the reaction.
   * @param params.data.createdAt (optional) The date the reaction is set to be created.
   * @returns The created comment reaction.
   */
  async addCommentReaction(params) {
    const { roomId, threadId, commentId, data } = params;
    const res = await this.post(
      _core.url`/v2/rooms/${roomId}/threads/${threadId}/comments/${commentId}/add-reaction`,
      {
        ...data,
        createdAt: _optionalChain([data, 'access', _16 => _16.createdAt, 'optionalAccess', _17 => _17.toISOString, 'call', _18 => _18()])
      }
    );
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
    const reaction = await res.json();
    return _core.convertToCommentUserReaction.call(void 0, reaction);
  }
  /**
   * Removes a reaction from a comment.
   * @param params.roomId The room ID to remove the comment reaction from.
   * @param params.threadId The thread ID to remove the comment reaction from.
   * @param params.commentId The comment ID to remove the reaction from.
   * @param params.data.emoji The (emoji) reaction to remove.
   * @param params.data.userId The user ID of the user associated with the reaction.
   * @param params.data.removedAt (optional) The date the reaction is set to be removed.
   */
  async removeCommentReaction(params) {
    const { roomId, threadId, data } = params;
    const res = await this.post(
      _core.url`/v2/rooms/${roomId}/threads/${threadId}/comments/${params.commentId}/remove-reaction`,
      {
        ...data,
        removedAt: _optionalChain([data, 'access', _19 => _19.removedAt, 'optionalAccess', _20 => _20.toISOString, 'call', _21 => _21()])
      }
    );
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
  }
  /**
   * Returns the inbox notifications for a user.
   * @param params.userId The user ID to get the inbox notifications from.
   * @param params.inboxNotificationId The ID of the inbox notification to get.
   */
  async getInboxNotification(params) {
    const { userId, inboxNotificationId } = params;
    const res = await this.get(
      _core.url`/v2/users/${userId}/inbox-notifications/${inboxNotificationId}`
    );
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
    return _core.convertToInboxNotificationData.call(void 0, 
      await res.json()
    );
  }
  /**
   * Returns the inbox notifications for a user.
   * @param params.userId The user ID to get the inbox notifications from.
   * @param params.query The query to filter inbox notifications by. It is based on our query language and can filter by unread.
   */
  async getInboxNotifications(params) {
    const { userId } = params;
    let query;
    if (typeof params.query === "string") {
      query = params.query;
    } else if (typeof params.query === "object") {
      query = _core.objectToQuery.call(void 0, params.query);
    }
    const res = await this.get(_core.url`/v2/users/${userId}/inbox-notifications`, {
      query
    });
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
    const { data } = await res.json();
    return {
      data: data.map(_core.convertToInboxNotificationData)
    };
  }
  /**
   * Gets the user's room notification settings.
   * @param params.userId The user ID to get the room notifications from.
   * @param params.roomId The room ID to get the room notification settings from.
   */
  async getRoomNotificationSettings(params) {
    const { userId, roomId } = params;
    const res = await this.get(
      _core.url`/v2/rooms/${roomId}/users/${userId}/notification-settings`
    );
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
    return await res.json();
  }
  /**
   * Updates the user's room notification settings.
   * @param params.userId The user ID to update the room notification settings for.
   * @param params.roomId The room ID to update the room notification settings for.
   * @param params.data The new room notification settings for the user.
   */
  async updateRoomNotificationSettings(params) {
    const { userId, roomId, data } = params;
    const res = await this.post(
      _core.url`/v2/rooms/${roomId}/users/${userId}/notification-settings`,
      data
    );
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
    return await res.json();
  }
  /**
   * Delete the user's room notification settings.
   * @param params.userId The user ID to delete the room notification settings from.
   * @param params.roomId The room ID to delete the room notification settings from.
   */
  async deleteRoomNotificationSettings(params) {
    const { userId, roomId } = params;
    const res = await this.delete(
      _core.url`/v2/rooms/${roomId}/users/${userId}/notification-settings`
    );
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
  }
  /**
   * Update a room ID.
   * @param params.roomId The current ID of the room.
   * @param params.newRoomId The new room ID.
   */
  async updateRoomId(params) {
    const { currentRoomId, newRoomId } = params;
    const res = await this.post(
      _core.url`/v2/rooms/${currentRoomId}/update-room-id`,
      {
        newRoomId
      }
    );
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
    const data = await res.json();
    return {
      ...data,
      createdAt: new Date(data.createdAt),
      lastConnectionAt: data.lastConnectionAt ? new Date(data.lastConnectionAt) : void 0
    };
  }
  async triggerInboxNotification(params) {
    const res = await this.post(_core.url`/v2/inbox-notifications/trigger`, params);
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
  }
  /**
   * Deletes an inbox notification for a user.
   * @param params.userId The user ID for which to delete the inbox notification.
   * @param params.inboxNotificationId The ID of the inbox notification to delete.
   */
  async deleteInboxNotification(params) {
    const { userId, inboxNotificationId } = params;
    const res = await this.delete(
      _core.url`/v2/users/${userId}/inbox-notifications/${inboxNotificationId}`
    );
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
  }
  /**
   * Deletes all inbox notifications for a user.
   * @param params.userId The user ID for which to delete all the inbox notifications.
   */
  async deleteAllInboxNotifications(params) {
    const { userId } = params;
    const res = await this.delete(_core.url`/v2/users/${userId}/inbox-notifications`);
    if (!res.ok) {
      const text = await res.text();
      throw new LiveblocksError(res.status, text);
    }
  }
};
var LiveblocksError = class extends Error {
  constructor(status, message = "") {
    super(message);
    this.name = "LiveblocksError";
    this.status = status;
  }
};

// src/webhooks.ts
var _base64 = require('@stablelib/base64'); var base64 = _interopRequireWildcard(_base64);
var _fastsha256 = require('fast-sha256'); var sha256 = _interopRequireWildcard(_fastsha256);
var _WebhookHandler = class _WebhookHandler {
  constructor(secret) {
    if (!secret) throw new Error("Secret is required");
    if (typeof secret !== "string") throw new Error("Secret must be a string");
    if (secret.startsWith(_WebhookHandler.secretPrefix) === false)
      throw new Error("Invalid secret, must start with whsec_");
    const secretKey = secret.slice(_WebhookHandler.secretPrefix.length);
    this.secretBuffer = Buffer.from(secretKey, "base64");
  }
  /**
   * Verifies a webhook request and returns the event
   */
  verifyRequest(request) {
    const { headers, rawBody } = request;
    const { webhookId, timestamp, rawSignatures } = this.verifyHeaders(headers);
    if (typeof rawBody !== "string") {
      throw new Error(
        `Invalid rawBody field, must be a string, got "${typeof rawBody}" instead. It is likely that you need to JSON.stringify the body before passing it.`
      );
    }
    this.verifyTimestamp(timestamp);
    const signature = this.sign(`${webhookId}.${timestamp}.${rawBody}`);
    const expectedSignatures = rawSignatures.split(" ").map((rawSignature) => {
      const [, parsedSignature] = rawSignature.split(",");
      return parsedSignature;
    }).filter(isNotUndefined);
    if (expectedSignatures.includes(signature) === false)
      throw new Error(
        `Invalid signature, expected one of ${expectedSignatures.join(
          ", "
        )}, got ${signature}`
      );
    const event = JSON.parse(rawBody);
    this.verifyWebhookEventType(event);
    return event;
  }
  /**
   * Verifies the headers and returns the webhookId, timestamp and rawSignatures
   */
  verifyHeaders(headers) {
    const usingNativeHeaders = typeof Headers !== "undefined" && headers instanceof Headers;
    const normalizedHeaders = usingNativeHeaders ? Object.fromEntries(headers) : headers;
    const sanitizedHeaders = {};
    Object.keys(normalizedHeaders).forEach((key) => {
      sanitizedHeaders[key.toLowerCase()] = normalizedHeaders[key];
    });
    const webhookId = sanitizedHeaders["webhook-id"];
    if (typeof webhookId !== "string")
      throw new Error("Invalid webhook-id header");
    const timestamp = sanitizedHeaders["webhook-timestamp"];
    if (typeof timestamp !== "string")
      throw new Error("Invalid webhook-timestamp header");
    const rawSignatures = sanitizedHeaders["webhook-signature"];
    if (typeof rawSignatures !== "string")
      throw new Error("Invalid webhook-signature header");
    return { webhookId, timestamp, rawSignatures };
  }
  /**
   * Signs the content with the secret
   * @param content
   * @returns `string`
   */
  sign(content) {
    const encoder = new TextEncoder();
    const toSign = encoder.encode(content);
    return base64.encode(sha256.hmac(this.secretBuffer, toSign));
  }
  /**
   * Verifies that the timestamp is not too old or in the future
   */
  verifyTimestamp(timestampHeader) {
    const now = Math.floor(Date.now() / 1e3);
    const timestamp = parseInt(timestampHeader, 10);
    if (isNaN(timestamp)) {
      throw new Error("Invalid timestamp");
    }
    if (timestamp < now - WEBHOOK_TOLERANCE_IN_SECONDS) {
      throw new Error("Timestamp too old");
    }
    if (timestamp > now + WEBHOOK_TOLERANCE_IN_SECONDS) {
      throw new Error("Timestamp in the future");
    }
  }
  /**
   * Ensures that the event is a known event type
   * or throws and prompts the user to upgrade to a higher version of @liveblocks/node
   */
  verifyWebhookEventType(event) {
    if (event && event.type && [
      "storageUpdated",
      "userEntered",
      "userLeft",
      "roomCreated",
      "roomDeleted",
      "commentCreated",
      "commentEdited",
      "commentDeleted",
      "commentReactionAdded",
      "commentReactionRemoved",
      "threadMetadataUpdated",
      "threadCreated",
      "threadDeleted",
      "ydocUpdated",
      "notification",
      "threadMarkedAsResolved",
      "threadMarkedAsUnresolved"
    ].includes(event.type)) {
      if (event.type === "notification") {
        const notification = event;
        if (notification.data.kind === "thread" || notification.data.kind === "textMention" || notification.data.kind.startsWith("$")) {
          return;
        } else {
          throw new Error(
            `Unknown notification kind: ${notification.data.kind}`
          );
        }
      }
      return;
    }
    throw new Error(
      "Unknown event type, please upgrade to a higher version of @liveblocks/node"
    );
  }
};
_WebhookHandler.secretPrefix = "whsec_";
var WebhookHandler = _WebhookHandler;
var WEBHOOK_TOLERANCE_IN_SECONDS = 5 * 60;
var isNotUndefined = (value) => value !== void 0;
function isThreadNotificationEvent(event) {
  return event.type === "notification" && event.data.kind === "thread";
}
function isTextMentionNotificationEvent(event) {
  return event.type === "notification" && event.data.kind === "textMention";
}

// src/index.ts




_core.detectDupes.call(void 0, PKG_NAME, PKG_VERSION, PKG_FORMAT);








exports.Liveblocks = Liveblocks; exports.LiveblocksError = LiveblocksError; exports.WebhookHandler = WebhookHandler; exports.getMentionedIdsFromCommentBody = _core.getMentionedIdsFromCommentBody; exports.isTextMentionNotificationEvent = isTextMentionNotificationEvent; exports.isThreadNotificationEvent = isThreadNotificationEvent; exports.stringifyCommentBody = _core.stringifyCommentBody;
//# sourceMappingURL=index.js.map